### Spark 内存管理

##### 1. 堆内和堆外内存

**堆内内存：**受 JVM GC 管理，会有 GC 开销

1. Executor 进程在启动时，由 JVM 向操作系统申请并**独占**的一块内存区域
2. 一旦申请成功，这部分内存就被该 JVM 进程锁定，操作系统和其他进程无法使用
3. Executor 内部运行的多个 **Task 线程** 则是**共享**这块内存的。
4. 直到 Executor 进程关闭（任务结束或动态资源回收）才会归还给操作系统。



**堆外内存**：不受 GC 管理，效率更高

1. 直接向操作系统进行申请的内存，不受JVM控制



##### 2. 堆外内存的优缺点

**优点：**

1. 减少了垃圾回收的工作，因为垃圾回收会暂停其他的工作
2. 加快了复制的速度。因为堆内在Flush到远程时，会先序列化，然后在发送；而堆外内存本身是序列化的相当于省略掉了这个工作。（堆外内存是**序列化**的，其占用的**内存大小可直接计算**；堆内内存是**非序列化**的对象，其占用的内存是通过周期性地**采样近似估算**而得。所以 Spark并不能准确记录实际可用的堆内内存，从而也就无法完全避免内存溢出OOM的异常。）

**缺点：**

1. 堆外内存难以控制，如果内存泄漏，那么很难排查 
2. 堆外内存相对来说，不适合存储很复杂的对象，适合存储简单对象或者扁平化对象



##### 3. spark静态内存管理：Storage， Execution 和 Other运行期间比例固定

**Storage 内存：**

1. 主要用于缓存 RDD 数据（Cache）、广播变量（Broadcast）以及解冻（Unroll）序列化数据。
2. **计算公式**：`JVM Heap * spark.storage.memoryFraction`
3. **安全性控制** `safetyFraction`（默认 0.9）是为了留出 10% 的预留空间防止 OOM。

**Execution 内存**：

1. 专门用于计算过程中的临时数据，例如 Shuffle 过程中的排序（**Sort**）、聚合（**Aggregation**）和连接（**Join**）缓存。
2. `safetyFraction`（默认 0.8）

**Other内存**：存储用户定义的数据结构、Spark 内部元数据以及 JVM 自身的开销。



**优点：**实现简单，配置直观。开发者可以明确知道每个区域的大小

**缺点**：缺乏灵活性

1. 如果一个任务需要大量计算内存（Execution）但没有 RDD 缓存，Storage 区域即便空闲，Execution 也无法占用，导致计算内存频繁溢写到磁盘（Spill to Disk）。
2. 反之，如果缓存空间不足，即便计算内存完全空闲，Storage 也无法扩容。



##### 4. 统一内存管理（Unified Memory Management）

**内存分配默认：**

- **Reserved Memory（预留内存）**：固定为 **300MB**，硬编码在代码中，专门留给 Spark 引擎内部使用，保障系统在极端压力下仍能运行。
- **Usable Memory（可用内存）**= “系统内存 - 预留内存”
- **Unified Memory（统一内存）** = Usable Memory * 0.6 = Storage + Execution
- **Other（其它内存）** = Usable Memory * 0.4



**动态占用机制：**

1. **Storage 借用 Execution**：当 Storage 内存不足而 Execution 内存有空闲时，Storage 可以占用 Execution 的空间；**强制回收：**一旦 Execution 需要这部分内存进行计算（如 Shuffle），Storage 占用的空间会被**强制淘汰**（Eviction），数据会被移出内存或存入磁盘。
2. **Execution 借用 Storage：**当 Execution 内存不足而 Storage 有空闲时，Execution 可以占用 Storage 的空间；**不可淘汰原则：**出于计算复杂性的考虑，Execution 占用的 Storage 内存**不可以被强制收回**。Storage 必须等待 Execution 计算完成并自动释放内存后才能拿回地盘。



##### 5. 内存持久化

| **存储级别**                 | **使用内存** | **使用磁盘** | **序列化** | **副本数** | **特点描述**                                             |
| ---------------------------- | ------------ | ------------ | ---------- | ---------- | -------------------------------------------------------- |
| **MEMORY_ONLY**              | 是           | 否           | 否         | 1          | **默认级别**（针对 RDD）。性能最高但最占空间。           |
| **MEMORY_AND_DISK**          | 是           | 是           | 否         | 1          | **默认级别**（针对 Dataset）。内存不足时数据溢写到磁盘。 |
| **MEMORY_ONLY_SER**          | 是           | 否           | **是**     | 1          | 存储序列化后的字节数组。省空间但读取时增加 CPU 负担。    |
| **MEMORY_AND_DISK_SER**      | 是           | 是           | **是**     | 1          | 类似上一个，但内存不足时会存入磁盘而非重新计算。         |
| **DISK_ONLY**                | 否           | 是           | 否         | 1          | 仅存磁盘。适用于重计算代价极高且内存极度稀缺的场景。     |
| **OFF_HEAP**                 | 否 (堆外)    | 否           | 是         | 1          | 存储在堆外内存，可减少 JVM GC 压力（需启用相关配置）。   |
| **..._2 (如 MEMORY_ONLY_2)** | 是/否        | 是/否        | 视情况     | **2**      | 为上述任意级别增加一个副本，分布在不同节点以增强容错性。 |



1. 序列化与反序列化：
   - [ ] **序列化（Serialized）**：将对象转为字节数组。这能显著降低内存占用（特别是使用 Kryo 序列化时），但读取时需要反序列化，会消耗更多 CPU。
   - [ ] **反序列化（Deserialized）**：直接存储 Java 对象，访问速度最快，但占用的空间通常是原始数据的 2~5 倍。
2. 内存与磁盘：
   - [ ] 如果内存能够放下所有数据，首选 `MEMORY_ONLY`
   - [ ] 如果内存紧张，建议使用 `MEMORY_ONLY_SER` 来压榨内存空间，而不是直接溢写到磁盘。因为从磁盘读取的速度往往慢于 CPU 反序列化的速度。
3. 副本与容错性：
   - [ ] 每一份数据副本发送到两个集群节点上
   - [ ] 如果某个节点宕机，可以直接从另一个节点读取，而不需要根据血缘（Lineage）重新计算



##### 6. 内存淘汰原则

- Spark 默认采用 **LRU（Least Recently Used）**算法进行淘汰。被淘汰的数据块是否消失取决于其**持久化级别**，如果是 `MEMORY_ONLY`，数据直接被丢弃，下次使用需重新计算；如果是 `MEMORY_AND_DISK`，数据会被溢写（Spill）到磁盘。
- 在统一内存管理中，Storage 和 Execution（执行内存）可以相互借用空间，Execution 可以**强制淘汰** Storage 中的缓存块来获取空间，Storage **无法驱逐** Execution，只能等待其计算完成自动释放。











